# 基于模块Humble，镭神 N10 SLAM添加pixhawk飞控的imu数据
**px4版本为1.13.3，其余版本没有验证**

---

## 机载电脑下载MAVROS，实现通信

修改QGC中参数
```
# mavlink通道0设置为TELLEM1
- MAV_1_CONFIG     TELLEM2

# 设置为onborad模式才会发送线加速度
- MAV_1_MODE       Onboard

# 设置TELLEM2通信波特率
- SER_TEL1_BAUD    921600 8N1

# 设置TELLEM1的速度b/s，0则飞控自适应
- MAV_1_RATE       0
```

```
# QGC的MavLink工作台输入
mavlink status streams
# 可见imu输出频率2.5
instance #1:
HIGHRES_IMU                    50.00 (2.500)
# 设置输出频率50hz
mavlink stream -r 50 -s HIGHRES_IMU
mavlink status streams
# 可见
instance #1:
HIGHRES_IMU                    50.00 (2.500)
```

**注意飞控不能3v3供电**
```
模块通过串口/dev/ttyS3连接TELLEM2
TELLEM2  5V  TX  RX CTS RTS GND  
mode     3V3 3V3 GND TX RX
```

安装MAVROS

参考：https://blog.csdn.net/weixin_42037083/article/details/137102858

```bash
sudo apt-get install ros-humble-mavros ros-humble-mavros-extras
```

安装geographiclib

```bash
cd ~
git clone https://github.com/weisama/GeographicLib.git
sudo cp -r ~/GeographicLib /usr/share
rm -rf ~/GeographicLib
```

设置mode串口

查看串口消息

```bash
sudo dmesg | tail
ls /dev/ttyS*
sudo usermod -aG dialout $USER
sudo chmod 777 /dev/ttyS3
```

修改mavros串口设备和波特率

```bash
sudo nano /opt/ros/humble/share/mavros/launch/px4.launch
```

```xml
<arg name="fcu_url" default="/dev/ttyS3:921600" />
```

```bash
ros2 launch mavros px4.launch
ros2 launch mavros px4.launch fcu_url:=/dev/ttyS3:921600
ros2 topic list
```

### 检查MAVROS状态

```bash
# 飞控状态
ros2 topic echo /mavros/state

# EKF2的imu数据,坐标系为base_link则不修改tf变换
ros2 topic echo /mavros/imu/data

# 频率50hz满足要求
ros2 topic hz /mavros/imu/data

# 原始imu数据，不建议使用
ros2 topic echo /mavros/imu/data_raw
```

---

## pose_send功能包，slam输出tf作为飞控位置输入，并发送给串口4

```bash
cd ~/slam_ws/src
ros2 pkg create --build-type ament_cmake pose_send --dependencies rclcpp tf2_ros geometry_msgs
```

`mousepad ~/slam_ws/src/pose_send/src/pose_send_node.cpp`

```
#include "rclcpp/rclcpp.hpp"
#include "geometry_msgs/msg/pose_stamped.hpp"
#include "tf2_ros/transform_listener.h"
#include "tf2_ros/buffer.h"
#include "tf2_msgs/msg/tf_message.hpp"
#include "tf2_geometry_msgs/tf2_geometry_msgs.hpp"

#include <fcntl.h>
#include <termios.h>
#include <unistd.h>
#include <cmath>

class PoseSendNode : public rclcpp::Node
{
public:
    PoseSendNode() : Node("pose_send_node")
    {
        // 声明 use_sim_time
        if (!this->has_parameter("use_sim_time"))
            this->declare_parameter("use_sim_time", false);

        bool use_sim_time = this->get_parameter("use_sim_time").as_bool();
        if (use_sim_time)
            RCLCPP_INFO(this->get_logger(), "Using simulated time (use_sim_time=true)");

        // 发布到 MAVROS
        pose_pub_ = this->create_publisher<geometry_msgs::msg::PoseStamped>(
            "/mavros/vision_pose/pose", 10);

        // TF 缓冲区
        tf_buffer_ = std::make_unique<tf2_ros::Buffer>(this->get_clock(), tf2::durationFromSec(10.0));
        tf_listener_ = std::make_shared<tf2_ros::TransformListener>(*tf_buffer_);

        // 订阅 TF
        tf_sub_ = this->create_subscription<tf2_msgs::msg::TFMessage>(
            "/tf", 50,
            std::bind(&PoseSendNode::tf_callback, this, std::placeholders::_1));

        tf_static_sub_ = this->create_subscription<tf2_msgs::msg::TFMessage>(
            "/tf_static", 10,
            std::bind(&PoseSendNode::tf_callback, this, std::placeholders::_1));

        RCLCPP_INFO(this->get_logger(), "pose_send_node started, waiting for TFs (map → base_link)...");

        open_serial_port();
    }

private:
    //============================================================================
    // 串口初始化
    //============================================================================
    void open_serial_port()
    {
        serial_fd_ = open("/dev/ttyS4", O_RDWR | O_NOCTTY | O_NONBLOCK);
        if (serial_fd_ < 0)
        {
            RCLCPP_ERROR(this->get_logger(), "Failed to open /dev/ttyS4");
            return;
        }

        struct termios tty;
        tcgetattr(serial_fd_, &tty);

        cfsetospeed(&tty, B115200);
        cfsetispeed(&tty, B115200);

        tty.c_cflag &= ~PARENB;      // No parity
        tty.c_cflag &= ~CSTOPB;      // 1 stop bit
        tty.c_cflag &= ~CSIZE;
        tty.c_cflag |= CS8;          // 8 data bits
        tty.c_cflag &= ~CRTSCTS;     // No HW flow control
        tty.c_cflag |= CREAD | CLOCAL;

        tty.c_lflag &= ~ICANON;
        tty.c_lflag &= ~ECHO;
        tty.c_lflag &= ~ECHOE;
        tty.c_lflag &= ~ECHONL;
        tty.c_lflag &= ~ISIG;

        tty.c_iflag &= ~(IXON | IXOFF | IXANY);
        tty.c_iflag &= ~(IGNBRK | BRKINT | PARMRK | ISTRIP | INLCR | IGNCR | ICRNL);

        tty.c_oflag &= ~OPOST;
        tty.c_oflag &= ~ONLCR;

        tty.c_cc[VTIME] = 1;
        tty.c_cc[VMIN] = 0;

        tcsetattr(serial_fd_, TCSANOW, &tty);

        RCLCPP_INFO(this->get_logger(), "Serial /dev/ttyS4 opened (115200 8N1)");
    }

    //============================================================================
    // 串口发送函数 (按协议封包)
    //============================================================================
    void send_serial(int16_t x, int16_t y, int16_t z, int16_t yaw)
    {
        if (serial_fd_ < 0)
            return;

        uint8_t buf[10];
        buf[0] = 0xAA;

        buf[1] = (x >> 8) & 0xFF;
        buf[2] = (x)&0xFF;

        buf[3] = (y >> 8) & 0xFF;
        buf[4] = (y)&0xFF;

        buf[5] = (z >> 8) & 0xFF;
        buf[6] = (z)&0xFF;

        buf[7] = (yaw >> 8) & 0xFF;
        buf[8] = (yaw)&0xFF;

        buf[9] = 0x0A;

        write(serial_fd_, buf, 10);
    }

    //============================================================================
    // TF 回调
    //============================================================================
    void tf_callback(const tf2_msgs::msg::TFMessage::SharedPtr msg)
    {
        (void)msg;

        try
        {
            auto transform_stamped =
                tf_buffer_->lookupTransform("map", "base_link", rclcpp::Time(0), tf2::durationFromSec(0.1));

            geometry_msgs::msg::PoseStamped pose_msg;
            pose_msg.header = transform_stamped.header;
            pose_msg.header.frame_id = "map";
            pose_msg.pose.position.x = transform_stamped.transform.translation.x;
            pose_msg.pose.position.y = transform_stamped.transform.translation.y;
            pose_msg.pose.position.z = transform_stamped.transform.translation.z;
            pose_msg.pose.orientation = transform_stamped.transform.rotation;

            // 发布给 MAVROS
            pose_pub_->publish(pose_msg);

            //===========================================
            // 单位转换：m→cm, rad→deg
            //===========================================
            int16_t x_cm = static_cast<int16_t>(pose_msg.pose.position.x * 100.0);
            int16_t y_cm = static_cast<int16_t>(pose_msg.pose.position.y * 100.0);
            int16_t z_cm = static_cast<int16_t>(pose_msg.pose.position.z * 100.0);

            tf2::Quaternion q(
                pose_msg.pose.orientation.x,
                pose_msg.pose.orientation.y,
                pose_msg.pose.orientation.z,
                pose_msg.pose.orientation.w);

            double roll, pitch, yaw_rad;
            tf2::Matrix3x3(q).getRPY(roll, pitch, yaw_rad);

            int16_t yaw_deg = static_cast<int16_t>(yaw_rad * 180.0 / M_PI);

            // 发送串口
            send_serial(x_cm, y_cm, z_cm, yaw_deg);
        }
        catch (tf2::TransformException &ex)
        {
            RCLCPP_WARN_THROTTLE(this->get_logger(), *this->get_clock(), 5000,
                                 "Waiting for TF map→base_link: %s", ex.what());
        }
    }

    //============================================================================
    // 成员变量
    //============================================================================
    int serial_fd_ = -1;

    rclcpp::Publisher<geometry_msgs::msg::PoseStamped>::SharedPtr pose_pub_;
    rclcpp::Subscription<tf2_msgs::msg::TFMessage>::SharedPtr tf_sub_;
    rclcpp::Subscription<tf2_msgs::msg::TFMessage>::SharedPtr tf_static_sub_;

    std::unique_ptr<tf2_ros::Buffer> tf_buffer_;
    std::shared_ptr<tf2_ros::TransformListener> tf_listener_;
};

//============================================================================
// main
//============================================================================
int main(int argc, char **argv)
{
    rclcpp::init(argc, argv);
    auto node = std::make_shared<PoseSendNode>();
    rclcpp::spin(node);
    rclcpp::shutdown();
    return 0;
}
```


`mousepad ~/slam_ws/src/pose_send/CMakeLists.txt`

```
cmake_minimum_required(VERSION 3.8)
project(pose_send)

find_package(ament_cmake REQUIRED)
find_package(rclcpp REQUIRED)
find_package(geometry_msgs REQUIRED)
find_package(tf2 REQUIRED)
find_package(tf2_ros REQUIRED)
find_package(tf2_msgs REQUIRED)
find_package(tf2_geometry_msgs REQUIRED)

add_executable(pose_send_node src/pose_send_node.cpp)
ament_target_dependencies(pose_send_node
  rclcpp
  geometry_msgs
  tf2
  tf2_ros
  tf2_msgs
  tf2_geometry_msgs
)

install(TARGETS
  pose_send_node
  DESTINATION lib/${PROJECT_NAME}
)

ament_package()
```

`mousepad ~/slam_ws/src/pose_send/package.xml`

```
  <buildtool_depend>ament_cmake</buildtool_depend>

  <depend>rclcpp</depend>
  <depend>geometry_msgs</depend>
  <depend>tf2</depend>
  <depend>tf2_ros</depend>
  <depend>tf2_msgs</depend>
  <depend>tf2_geometry_msgs</depend>
```

```
cd ~/slam_ws
colcon build --packages-select pose_send
```

```
# 循环播放bag，使用模拟时间
ros2 bag play ~/slam_ws/src/upper/bag/*.db3 --loop --clock
ros2 run pose_send pose_send_node --ros-args -p use_sim_time:=true
ros2 topic echo /mavros/vision_pose/pose

# 本机测试串口接收
sudo minicom -D /dev/ttyUSB0 -b 115200

#数据格式
发送频率是坐标话题频率
波特率115200
数据类型8N1
xyz单位为cm，yaw单位为度
通信协议：
帧头 0xAA
x高八位
x第八位
y高八位
y第八位
z高八位
z第八位
yaw高八位
yaw第八位
帧尾 0x0A
```

---

## QGC设置飞控使用slam外部视觉坐标和yaw输入

### 重要参数，关乎slam定点飞行精度

- EKF2_EVP_NOISE = 1.0  
  为slam位置数据的方差，影响slam位置数据的置信度  
  过大会导致移动过程slam位置置信度较低，来回震荡  
  过小会导致LOCAL_POSITION_NED发散，EKF2估计坐标偏离slam位置  
  实测0.1过小

- EKF2_EVA_NOISE = 10  
  为slam姿态数据的方差，影响slam姿态数据的置信度

- EKF2_EV_DELAY = 125  
  slam数据延迟，从PX4_log.txt中日志查看slam数据四元素和imu四元素的延迟

- EKF2_AID_MASK = 24  
  勾选外部视觉（雷达）位置和yaw，用于EKF2（扩展卡尔曼），使用slam作为位姿数据来源  

- EKF2_HGT_MODE = 0
  默认，使用气压计

### 其他参数

- MIS_TAKEOFF_ALT = 1  
  无人机降落最小高度

- CBRK_SUPPLY_CHK = 894281  
  无备用电池允许遥控解锁

- SDLOG_PROFILE = 129  
  日志记录内容默认+机器视觉

- SDLOG_MODE = from boot until shutdown  
  日志记录从上电到掉电

- SYS_CTRL_ALLOC = Enable  
  允许控制分配功能

- COM_RC_OVERRIDE = 3  
  允许遥控器打杆时强制退出Offboard模式，并切换至Position模式

- COM_RC_STICK_OV = 20  
  定义打杆幅度阈值（例如摇杆偏移超过20%触发）

---

## 设置脚本开机自启动slam

```bash
gedit ~/autostart.sh
```

写入：

```bash
#!/bin/bash
# 加载环境
source /opt/ros/humble/setup.bash
source /home/cat/slam_ws/install/setup.bash
# 启动命令
ros2 launch lidar_filter lidar_filter_with_driver.launch.py &
sleep 3
ros2 launch rf2o_laser_odometry rf2o_laser_odometry.launch.py publish_tf:=true &
sleep 3
ros2 launch karto_slam online_launch.py &
sleep 1
ros2 launch upper upper_launch.py tcp_ip:=0.0.0.0 tcp_port:=6666 &
sleep 1
sudo nmcli dev wifi hotspot ifname wlan0 ssid slam_mode password 12345678 &
sleep 1
ros2 launch mavros px4.launch &
sleep 1
ros2 run pose_send pose_send_node &
# 防止脚本退出
while true; do sleep 1000; done
```

```bash
chmod +x ~/autostart.sh
```

```bash
sudo nano /etc/systemd/system/autostart.service
```

写入：

```
[Unit]
Description=ROS 2 Autostart Service
After=network.target
[Service]
Type=simple
User=cat
ExecStart=/home/cat/autostart.sh
Restart=on-failure
RestartSec=5s
[Install]
WantedBy=multi-user.target
```

```bash
sudo systemctl daemon-reload
sudo systemctl enable autostart.service
sudo systemctl start autostart.service
```

停止服务

```bash
sudo systemctl stop autostart.service
```

禁用开机自启动

```bash
sudo systemctl disable autostart.service
```

## 功能包可视化yaw延迟，推算EKF2_EV_DELAY


```
cd ~/slam_ws
colcon build --packages-select visualize_delay
```

```
ros2 launch visualize_delay visualize_delay.launch.py
```
