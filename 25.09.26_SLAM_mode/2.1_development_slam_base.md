# SLAM模块一些基础功能包

# 鲁班猫2使用SDK编译的Ubuntu22.04+ROS 2 Humble  

---

### 创建工作空间
```bash
rm -rf ~/slam_ws/
mkdir -p ~/slam_ws/src
cd ~/slam_ws
rosdepc update
rosdepc install --from-paths src --ignore-src -y
colcon build
```

---

### 固定串口
```bash
ls /dev/tty*
sudo apt install udev

# 查看供应商ID和设备ID
udevadm info -q property -n /dev/ttyACM0 | grep -E "(ID_VENDOR_ID|ID_MODEL_ID)"
# 查看序列号
udevadm info -q property -n /dev/ttyACM0 | grep ID_SERIAL_SHORT
# 查看产品名称
udevadm info -q property -n /dev/ttyACM0 | grep ID_MODEL=
```

| 字段 | 值 |
|---|---|
| ID_VENDOR_ID | 1a86 |
| ID_MODEL_ID | 55d4 |
| ID_SERIAL_SHORT | 5954004011 |
| ID_MODEL | USB Single Serial |

```bash
sudo nano /etc/udev/rules.d/99-usb-serial.rules
```

```udev
SUBSYSTEM=="tty", ATTRS{idVendor}=="1a86", ATTRS{idProduct}=="55d4", SYMLINK+="usb_robot", MODE="0666"
```

```bash
sudo udevadm control --reload-rules
sudo udevadm trigger
ls -l /dev/usb_robot
```

---

### 获取点云（N10 驱动）
```bash
# 安装各种依赖
sudo apt install ros-humble-diagnostic-updater libpcap-dev
sudo apt install libicu70=70.1-2
sudo apt install libpcl-dev
sudo apt-get install ros-$ROS_DISTRO-pcl-conversions ros-$ROS_DISTRO-pcl-ros


rm -rf ~/slam_ws
mkdir -p ~/slam_ws/src
cd ~/slam_ws/src

# 任选其一分支
git clone -b N10_V1.0 https://github.com/Lslidar/Lslidar_ROS2_driver.git
# git clone -b M10P/N10P https://github.com/Lslidar/Lslidar_ROS2_driver.git

cp -r Lslidar_ROS2_driver/lslidar_driver .
cp -r Lslidar_ROS2_driver/lslidar_msgs .
rm -rf Lslidar_ROS2_driver
```

#### 修改参数
```bash
gedit ~/slam_ws/src/lslidar_driver/src/lslidar_driver.cc
# 将 ttyUSB0 改为 usb_robot
```

```bash
gedit ~/slam_ws/src/lslidar_driver/params/lsx10.yaml
lidar_name: N10
ttyUSB0 -> usb_robot
# 后续滤波
scan_topic: /scan_raw
```

#### 修改launch，使得上一步修改参数非必要

**从~/slam_ws/src/upper/config获取关键参数，覆盖原本的参数文件**

```bash
gedit ~/slam_ws/src/upper/config/params.yaml
```

```
# 雷达型号选择: M10,  N10_P
lidar_name: N10

# 雷达数据发布的话题
scan_topic: /scan_raw

# 雷达串口设备
serial_port_: /dev/usb_robot

```

```bash
gedit ~/slam_ws/src/lslidar_driver/launch/lslidar_launch.py
```

```
#!/usr/bin/python3
import os
import yaml

from ament_index_python.packages import get_package_share_directory
from launch import LaunchDescription
from launch_ros.actions import LifecycleNode

def generate_launch_description():
    # === 1. 获取参数文件路径 ===
    user_ws = os.path.expanduser('~/slam_ws/src/upper/config')
    param_file = os.path.join(user_ws, 'params.yaml')
    
    # 读取用户参数
    if os.path.exists(param_file):
        with open(param_file, 'r') as f:
            user_params = yaml.safe_load(f)
        lidar_name = user_params.get('lidar_name', 'N10')  # 默认 N10
        scan_topic = user_params.get('scan_topic', '/scan_raw')  # 默认 /scan_raw
        serial_port_ = user_params.get('serial_port_', '/dev/usb_robot')  # 默认 /dev/usb_robot
    else:
        lidar_name = 'N10'
        scan_topic = '/scan_raw'
        serial_port_ = '/dev/usb_robot'
        print(f"[WARN] {param_file} 不存在，使用默认参数")

    # === 2. 驱动 YAML 文件路径 ===
    driver_dir = os.path.join(get_package_share_directory('lslidar_driver'), 'params', 'lsx10.yaml')

    # === 3. 启动 LifecycleNode ===
    driver_node = LifecycleNode(
        package='lslidar_driver',
        executable='lslidar_driver_node',
        name='lslidar_driver_node',
        output='screen',
        emulate_tty=True,
        namespace='',
        parameters=[
            driver_dir,
            {
                'lidar_name': lidar_name,
                'scan_topic': scan_topic,
                'serial_port_': serial_port_
            }
        ],
    )

    return LaunchDescription([driver_node])
```

#### 编译 & 运行
```bash
cd ~/slam_ws
colcon build --packages-select lslidar_msgs
colcon build --packages-select lslidar_driver
```

```bash
echo "source ~/slam_ws/install/setup.bash" >> ~/.bashrc
source ~/.bashrc
```

```bash
# 启动雷达
ros2 launch lslidar_driver lslidar_launch.py
# 独立可视化
rviz2 -d ~/slam_ws/src/lslidar_driver/rviz/lslidar.rviz
```

---

### 点云滤波，固定点云数量

```bash
cd ~/slam_ws/src
ros2 pkg create --build-type ament_cmake lidar_filter --dependencies rclcpp sensor_msgs
mkdir -p ~/slam_ws/src/lidar_filter/launch
```

`gedit ~/slam_ws/src/lidar_filter/src/lidar_filter.cpp`
```cpp
#include "rclcpp/rclcpp.hpp"
#include "sensor_msgs/msg/laser_scan.hpp"
#include <vector>
#include <algorithm>
#include <string>
#include <cmath>

using std::placeholders::_1;

class LidarFilter : public rclcpp::Node
{
public:
  LidarFilter()
  : Node("lidar_filter")
  {
    // 参数：目标点数和输入话题
    this->declare_parameter<int>("target_size", 450);
    this->declare_parameter<std::string>("scan_topic", "/scan_raw");

    this->get_parameter("target_size", target_size_);
    this->get_parameter("scan_topic", scan_topic_);

    RCLCPP_INFO(this->get_logger(), "LidarFilter started: target_size=%d, scan_topic=%s", 
                target_size_, scan_topic_.c_str());

    // 发布过滤后的scan
    pub_ = this->create_publisher<sensor_msgs::msg::LaserScan>("/scan", 10);

    // 订阅原始scan，并在回调函数中立即处理并发布
    sub_ = this->create_subscription<sensor_msgs::msg::LaserScan>(
      scan_topic_, 10, std::bind(&LidarFilter::scanCallback, this, _1));
  }

private:
  void scanCallback(const sensor_msgs::msg::LaserScan::SharedPtr msg)
  {
    // 立即处理并发布过滤后的数据
    auto filtered_scan = processScan(*msg);
    pub_->publish(filtered_scan);
  }

  sensor_msgs::msg::LaserScan processScan(const sensor_msgs::msg::LaserScan& input_scan)
  {
    auto output_scan = input_scan;
    size_t original_size = input_scan.ranges.size();
    
    // 如果目标尺寸与原始尺寸相同，直接返回
    if (static_cast<size_t>(target_size_) == original_size) {
      return output_scan;
    }

    // 准备输出数组
    std::vector<float> new_ranges(target_size_, std::numeric_limits<float>::infinity());
    std::vector<float> new_intensities;
    if (!input_scan.intensities.empty()) {
      new_intensities.resize(target_size_, 0.0);
    }

    // 计算角度参数
    float original_angle_min = input_scan.angle_min;
    float original_angle_increment = input_scan.angle_increment;
    float output_angle_increment = (input_scan.angle_max - input_scan.angle_min) / (target_size_ - 1);
    
    output_scan.angle_increment = output_angle_increment;
    output_scan.ranges = new_ranges;
    output_scan.intensities = new_intensities;

    // 为每个输出点找到对应的原始点
    for (int out_idx = 0; out_idx < target_size_; ++out_idx) {
      float target_angle = original_angle_min + out_idx * output_angle_increment;
      
      // 找到最近的原始点索引
      int closest_idx = findClosestIndex(target_angle, original_angle_min, original_angle_increment, original_size);
      
      if (closest_idx >= 0 && static_cast<size_t>(closest_idx) < original_size) {
        // 使用最近邻插值
        output_scan.ranges[out_idx] = input_scan.ranges[closest_idx];
        if (!input_scan.intensities.empty() && !output_scan.intensities.empty()) {
          output_scan.intensities[out_idx] = input_scan.intensities[closest_idx];
        }
      }
    }

    return output_scan;
  }

  int findClosestIndex(float target_angle, float angle_min, float angle_increment, size_t size)
  {
    // 计算目标角度对应的索引
    float raw_index = (target_angle - angle_min) / angle_increment;
    
    // 四舍五入到最近的整数索引
    int index = static_cast<int>(std::round(raw_index));
    
    // 确保索引在有效范围内
    if (index < 0) return 0;
    if (static_cast<size_t>(index) >= size) return static_cast<int>(size) - 1;
    
    return index;
  }

  bool isValidMeasurement(float range)
  {
    return std::isfinite(range) && range >= 0.0f;
  }

  std::string scan_topic_;
  int target_size_;

  rclcpp::Subscription<sensor_msgs::msg::LaserScan>::SharedPtr sub_;
  rclcpp::Publisher<sensor_msgs::msg::LaserScan>::SharedPtr pub_;
};

int main(int argc, char **argv)
{
  rclcpp::init(argc, argv);
  rclcpp::spin(std::make_shared<LidarFilter>());
  rclcpp::shutdown();
  return 0;
}
```

`gedit ~/slam_ws/src/lidar_filter/launch/lidar_filter_with_driver.launch.py`

```bash
#!/usr/bin/python3
import os
import yaml

from ament_index_python.packages import get_package_share_directory
from launch import LaunchDescription
from launch_ros.actions import Node
from launch_ros.actions import LifecycleNode
from launch.actions import IncludeLaunchDescription
from launch.launch_description_sources import PythonLaunchDescriptionSource

def generate_launch_description():
    # === 1. 获取用户参数文件路径 (相对包路径) ===
    upper_pkg_dir = get_package_share_directory('upper')
    param_file = os.path.join(upper_pkg_dir, 'config', 'params.yaml')
    
    if os.path.exists(param_file):
        with open(param_file, 'r') as f:
            user_params = yaml.safe_load(f)
        lidar_name = user_params.get('lidar_name', 'N10')
        scan_topic = user_params.get('scan_topic', '/scan_raw')
        serial_port_ = user_params.get('serial_port_', '/dev/usb_robot')
    else:
        lidar_name = 'N10'
        scan_topic = '/scan_raw'
        serial_port_ = '/dev/usb_robot'
        print(f"[WARN] {param_file} 不存在，使用默认参数")

    # === 2. 根据雷达型号设置 target_size ===
    if lidar_name == "N10":
        target_size = 450
    elif lidar_name == "N10_P":
        target_size = 530
    elif lidar_name == "M10":
        target_size = 1000
    elif lidar_name == "M10_P":
        target_size = 1667
    else:
        target_size = 450
        print(f"[WARN] Unknown lidar_name={lidar_name}, default target_size=450")

    # === 3. driver YAML 文件路径 ===
    driver_yaml = os.path.join(get_package_share_directory('lslidar_driver'), 'params', 'lsx10.yaml')

    # === 4. 启动 lslidar_driver LifecycleNode ===
    lslidar_driver_node = LifecycleNode(
        package='lslidar_driver',
        executable='lslidar_driver_node',
        name='lslidar_driver_node',
        output='screen',
        emulate_tty=True,
        namespace='',
        parameters=[
            driver_yaml,
            {
                'lidar_name': lidar_name,
                'scan_topic': scan_topic,
                'serial_port_': serial_port_
            }
        ],
    )

    # === 5. 启动 LidarFilter 节点 ===
    lidar_filter_node = Node(
        package='lidar_filter',
        executable='lidar_filter_node',
        name='lidar_filter',
        output='screen',
        parameters=[{
            'target_size': target_size,
            'scan_topic': scan_topic
        }]
    )

    # === 6. 启动 TF broadcaster ===
    tf_launch_file = os.path.join(get_package_share_directory('tf'), 'launch', 'tf_broadcaster.launch.py')
    tf_broadcaster_node = IncludeLaunchDescription(
        PythonLaunchDescriptionSource(tf_launch_file)
    )

    # === 7. 返回 LaunchDescription ===
    return LaunchDescription([
        lslidar_driver_node,
        lidar_filter_node,
        tf_broadcaster_node
    ])
```

`gedit ~/slam_ws/src/lidar_filter/CMakeLists.txt`

```bash
cmake_minimum_required(VERSION 3.8)
project(lidar_filter)

# 默认编译选项
if(NOT CMAKE_CXX_STANDARD)
  set(CMAKE_CXX_STANDARD 17)
endif()

# 打印编译选项
add_compile_options(-Wall -Wextra -Wpedantic)

# 查找依赖
find_package(ament_cmake REQUIRED)
find_package(rclcpp REQUIRED)
find_package(sensor_msgs REQUIRED)

# -------------------------------
# 构建可执行节点
# -------------------------------
add_executable(lidar_filter_node src/lidar_filter.cpp)
ament_target_dependencies(lidar_filter_node rclcpp sensor_msgs)

# 安装可执行文件
install(TARGETS
  lidar_filter_node
  DESTINATION lib/${PROJECT_NAME}
)

# -------------------------------
# 安装 launch 文件
# -------------------------------
install(DIRECTORY
  launch
  DESTINATION share/${PROJECT_NAME}/
)

# -------------------------------
# 必需宏
# -------------------------------
ament_package()
```

#### 编译运行

```bash
cd ~/slam_ws
colcon build --packages-select lidar_filter

ros2 launch lidar_filter lidar_filter_with_driver.launch.py
```

---

### TF静态变换功能包

相较于raspi版以改进为**map -> odom -> base_link -> laser_link**

从~/slam_ws/src/upper/config/params.xml获取base_link -> laser_link

```bash
sudo apt-get install ros-$ROS_DISTRO-tf2-tools
sudo apt install ros-$ROS_DISTRO-rqt-tf-tree
```

```bash
cd ~/slam_ws/src
ros2 pkg create --build-type ament_cmake tf --dependencies rclcpp tf2_ros geometry_msgs
mkdir -p tf/launch
```

#### 源码

`gedit ~/slam_ws/src/tf/launch/tf_broadcaster.launch.py`

```python
from launch import LaunchDescription
from launch.actions import OpaqueFunction
from launch_ros.actions import Node
from launch_ros.substitutions import FindPackageShare
from launch.substitutions import PathJoinSubstitution
from math import radians
import yaml

def generate_launch_description():

    pkg_share = FindPackageShare('upper')
    param_file = PathJoinSubstitution([pkg_share, 'config', 'params.yaml'])

    def launch_nodes(context, *args, **kwargs):
        # 读取 YAML 文件
        param_path = param_file.perform(context)
        try:
            with open(param_path, 'r') as f:
                params = yaml.safe_load(f)
        except Exception:
            params = {}

        # 获取 base_link -> laser_link 参数，如果不存在就用 0
        x = float(params.get('x', 0)) / 100.0       # cm -> m
        y = float(params.get('y', 0)) / 100.0
        z = float(params.get('z', 0)) / 100.0
        roll = radians(float(params.get('roll', 0)))   # deg -> rad
        pitch = radians(float(params.get('pitch', 0)))
        yaw = radians(float(params.get('yaw', 0)))

        # 仿真时间参数
        use_sim_time = params.get('use_sim_time', False)

        return [
            # map -> odom
            Node(
                package='tf2_ros',
                executable='static_transform_publisher',
                name='map_to_odom_broadcaster',
                parameters=[{'use_sim_time': use_sim_time}],
                arguments=['--x', '0', '--y', '0', '--z', '0',
                           '--roll', '0', '--pitch', '0', '--yaw', '0',
                           '--frame-id', 'map', '--child-frame-id', 'odom'],
                output='screen'
            ),
            # odom -> base_link
            Node(
                package='tf2_ros',
                executable='static_transform_publisher',
                name='odom_to_base_broadcaster',
                parameters=[{'use_sim_time': use_sim_time}],
                arguments=['--x', '0', '--y', '0', '--z', '0',
                           '--roll', '0', '--pitch', '0', '--yaw', '0',
                           '--frame-id', 'odom', '--child-frame-id', 'base_link'],
                output='screen'
            ),
            # base_link -> laser_link
            Node(
                package='tf2_ros',
                executable='static_transform_publisher',
                name='base_to_laser_broadcaster',
                parameters=[{'use_sim_time': use_sim_time}],
                arguments=[
                    '--x', str(x),
                    '--y', str(y),
                    '--z', str(z),
                    '--roll', str(roll),
                    '--pitch', str(pitch),
                    '--yaw', str(yaw),
                    '--frame-id', 'base_link',
                    '--child-frame-id', 'laser_link'
                ],
                output='screen'
            )
        ]

    return LaunchDescription([
        OpaqueFunction(function=launch_nodes)
    ])
```

`gedit ~/slam_ws/src/tf/src/tf_broadcaster.cpp`
```cpp
#include <memory>
#include "rclcpp/rclcpp.hpp"
#include "tf2_ros/static_transform_broadcaster.h"
#include "geometry_msgs/msg/transform_stamped.h"
#include <tf2/LinearMath/Quaternion.h>

class StaticTFBroadcaster : public rclcpp::Node
{
public:
    StaticTFBroadcaster()
    : Node("tf_broadcaster")
    {
        tf_broadcaster_ = std::make_shared<tf2_ros::StaticTransformBroadcaster>(this);
        
        // 发布静态变换
        publish_transforms();
    }

private:
    void publish_transforms()
    {
        std::vector<geometry_msgs::msg::TransformStamped> transforms;
        
        // map -> odom 变换
        auto map_to_odom = create_transform("map", "odom", 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
        transforms.push_back(map_to_odom);
        
        // odom -> base_link 变换
        auto odom_to_base = create_transform("odom", "base_link", 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
        transforms.push_back(odom_to_base);
        
        // base_link -> laser_link 变换
        auto base_to_laser = create_transform("base_link", "laser_link", 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
        transforms.push_back(base_to_laser);
        
        // 发布所有变换
        tf_broadcaster_->sendTransform(transforms);
        
        RCLCPP_INFO(this->get_logger(), "Published static transforms");
    }
    
    geometry_msgs::msg::TransformStamped create_transform(
        const std::string& parent_frame,
        const std::string& child_frame,
        double x, double y, double z,
        double roll, double pitch, double yaw)
    {
        geometry_msgs::msg::TransformStamped transform;
        
        transform.header.stamp = this->get_clock()->now();
        transform.header.frame_id = parent_frame;
        transform.child_frame_id = child_frame;
        
        transform.transform.translation.x = x;
        transform.transform.translation.y = y;
        transform.transform.translation.z = z;
        
        // 将欧拉角转换为四元数
        tf2::Quaternion q;
        q.setRPY(roll, pitch, yaw);
        transform.transform.rotation.x = q.x();
        transform.transform.rotation.y = q.y();
        transform.transform.rotation.z = q.z();
        transform.transform.rotation.w = q.w();
        
        return transform;
    }
    
    std::shared_ptr<tf2_ros::StaticTransformBroadcaster> tf_broadcaster_;
};

int main(int argc, char** argv)
{
    rclcpp::init(argc, argv);
    auto node = std::make_shared<StaticTFBroadcaster>();
    rclcpp::spin(node);
    rclcpp::shutdown();
    return 0;
}
```

`gedit ~/slam_ws/src/tf/src/tf_broadcaster.cpp`

```
#include <memory>
#include "rclcpp/rclcpp.hpp"
#include "tf2_ros/static_transform_broadcaster.h"
#include "geometry_msgs/msg/transform_stamped.h"
#include <tf2/LinearMath/Quaternion.h>

class StaticTFBroadcaster : public rclcpp::Node
{
public:
    StaticTFBroadcaster()
    : Node("tf_broadcaster")
    {
        tf_broadcaster_ = std::make_shared<tf2_ros::StaticTransformBroadcaster>(this);
        
        // 发布静态变换
        publish_transforms();
    }

private:
    void publish_transforms()
    {
        std::vector<geometry_msgs::msg::TransformStamped> transforms;
        
        // map -> odom 变换
        auto map_to_odom = create_transform("map", "odom", 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
        transforms.push_back(map_to_odom);
        
        // odom -> base_link 变换
        auto odom_to_base = create_transform("odom", "base_link", 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
        transforms.push_back(odom_to_base);
        
        // base_link -> laser_link 变换
        auto base_to_laser = create_transform("base_link", "laser_link", 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
        transforms.push_back(base_to_laser);
        
        // 发布所有变换
        tf_broadcaster_->sendTransform(transforms);
        
        RCLCPP_INFO(this->get_logger(), "Published static transforms");
    }
    
    geometry_msgs::msg::TransformStamped create_transform(
        const std::string& parent_frame,
        const std::string& child_frame,
        double x, double y, double z,
        double roll, double pitch, double yaw)
    {
        geometry_msgs::msg::TransformStamped transform;
        
        transform.header.stamp = this->get_clock()->now();
        transform.header.frame_id = parent_frame;
        transform.child_frame_id = child_frame;
        
        transform.transform.translation.x = x;
        transform.transform.translation.y = y;
        transform.transform.translation.z = z;
        
        // 将欧拉角转换为四元数
        tf2::Quaternion q;
        q.setRPY(roll, pitch, yaw);
        transform.transform.rotation.x = q.x();
        transform.transform.rotation.y = q.y();
        transform.transform.rotation.z = q.z();
        transform.transform.rotation.w = q.w();
        
        return transform;
    }
    
    std::shared_ptr<tf2_ros::StaticTransformBroadcaster> tf_broadcaster_;
};

int main(int argc, char** argv)
{
    rclcpp::init(argc, argv);
    auto node = std::make_shared<StaticTFBroadcaster>();
    rclcpp::spin(node);
    rclcpp::shutdown();
    return 0;
}
```

`gedit ~/slam_ws/src/tf/CMakeLists.txt`
```cmake
cmake_minimum_required(VERSION 3.8)
project(tf)

# 检查编译器是否符合C++17标准
if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES "Clang")
  add_compile_options(-Wall -Wextra -Wpedantic)
endif()

# 查找依赖
find_package(ament_cmake REQUIRED)
find_package(rclcpp REQUIRED)
find_package(tf2_ros REQUIRED)
find_package(geometry_msgs REQUIRED)

# 如果有C++节点，添加可执行文件
if(EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/src/tf_broadcaster.cpp)
  add_executable(tf_broadcaster src/tf_broadcaster.cpp)
  ament_target_dependencies(tf_broadcaster 
    rclcpp 
    tf2_ros 
    geometry_msgs
  )
  
  # 安装可执行文件
  install(TARGETS
    tf_broadcaster
    DESTINATION lib/${PROJECT_NAME}
  )
endif()

# 安装launch文件
install(DIRECTORY
  launch
  DESTINATION share/${PROJECT_NAME}
)

if(BUILD_TESTING)
  find_package(ament_lint_auto REQUIRED)
  # 以下行会忽略ament_lint_auto找到的ament_lint_common包
  # 取消注释以执行lint测试
  # ament_lint_auto_find_test_dependencies()
endif()

ament_package()
```

`gedit ~/slam_ws/src/tf/package.xml`
```xml
<?xml version="1.0"?>
<?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypelayout="1.0"?>
<package format="3">
  <name>tf</name>
  <version>0.0.0</version>
  <description>C++ TF broadcaster package for ROS2 Foxy</description>
  <maintainer email="your_email@example.com">Your Name</maintainer>
  <license>Apache License 2.0</license>

  <buildtool_depend>ament_cmake</buildtool_depend>

  <depend>rclcpp</depend>
  <depend>tf2_ros</depend>
  <depend>geometry_msgs</depend>
  <depend>launch</depend>
  <depend>launch_ros</depend>

  <test_depend>ament_lint_auto</test_depend>
  <test_depend>ament_lint_common</test_depend>

  <export>
    <build_type>ament_cmake</build_type>
  </export>
</package>
```

#### 编译 & 测试
```bash
cd ~/slam_ws
colcon build --packages-select tf
```

```bash
source install/setup.bash
```

```bash
# 打印需在发布前，因为只发布一次
ros2 topic echo /tf_static
# 启动tf变换
ros2 launch tf tf_broadcaster.launch.py
# 可视化tf变换
ros2 run rqt_tf_tree rqt_tf_tree
```

---

### 串口输出坐标（已舍弃）
#### 法一：固定串口（USB-TTL）
同第 2 步，设备名 `usb_upper`。

#### 法二：GPIO 串口（ttyAMA0）
```bash
sudo nano /boot/firmware/config.txt
# 添加
dtoverlay=disable-bt
enable_uart=1
dtoverlay=miniuart-bt
```

#### 串口发送功能包
```bash
cd ~/slam_ws/src
ros2 pkg create --build-type ament_cmake serial_odom_sender --dependencies rclcpp nav_msgs
gedit ~/slam_ws/src/serial_odom_sender/src/serial_odom_sender.cpp
gedit ~/slam_ws/src/serial_odom_sender/CMakeLists.txt
# 编译
cd ~/slam_ws
colcon build --packages-select serial_odom_sender

# 启动点云
ros2 launch lslidar_driver lslidar_launch.py
# 启动里程计
ros2 launch rf2o_laser_odometry rf2o_laser_odometry.launch.py
# 串口输出坐标
ros2 run serial_odom_sender serial_odom_sender

# 图形化界面串口软件
sudo apt-get install cutecom
sudo cutecom

#数据格式
发送频率是坐标话题频率
波特率115200
数据类型8N1
xyz单位为cm，yaw单位为度
通信协议：
帧头 0xAA
x高八位
x第八位
y高八位
y第八位
z高八位
z第八位
yaw高八位
yaw第八位
帧尾 0x0A
```

### ubuntu 电脑接收打印（已舍弃）
```bash
mkdir -p ~/slam_ws/src
cd ~/slam_ws/src
ros2 pkg create --build-type ament_cmake serial_odom_receiver
gedit ~/slam_ws/src/serial_odom_receiver/src/serial_odom_receiver.cpp
gedit ~/slam_ws/src/serial_odom_receiver/package.xml
gedit ~/slam_ws/src/serial_odom_receiver/CMakeLists.txt
# 编译
cd ~/slam_ws
colcon build --packages-select serial_odom_receiver
# 运行
source ~/slam_ws/install/setup.bash
ros2 run serial_odom_receiver serial_odom_receive
```

---

### 开机自启动

`~/autostart.sh`

```bash
#!/bin/bash
# 加载环境
source /opt/ros/humble/setup.bash
source /home/chen/slam_ws/install/setup.bash
sleep 3
# 启动命令
ros2 launch lslidar_driver lslidar_launch.py &
sleep 3
ros2 launch rf2o_laser_odometry rf2o_laser_odometry.launch.py &
sleep 3
ros2 run serial_odom_sender serial_odom_sender &
# 防止脚本退出
while true; do sleep 1000; done
```

```bash
chmod +x ~/autostart.sh
```

`sudo nano /etc/systemd/system/autostart.service`
```ini
[Unit]
Description=ROS 2 Autostart Service
After=network.target

[Service]
Type=simple
User=chen
ExecStart=/home/chen/autostart.sh
Restart=on-failure
RestartSec=5s

[Install]
WantedBy=multi-user.target
```

#### 设置开机自启动
```bash
sudo systemctl daemon-reload
sudo systemctl enable autostart.service
sudo systemctl start autostart.service

# 停止服务
sudo systemctl stop autostart.service
# 禁用开机自启动
sudo systemctl disable autostart.service
```

---

### 创建功能包用于发送数据给上位机

```bash
sudo apt install nlohmann-json3-dev -y
cd ~/slam_ws/src
ros2 pkg create --build-type ament_cmake upper --dependencies rclcpp nav_msgs sensor_msgs nav_msgs tf2_msgs std_msgs
mkdir ~/slam_ws/src/upper/launch
```

`gedit ~/slam_ws/src/upper/launch/upper_launch.py`

```bash
import os
from launch import LaunchDescription
from launch_ros.actions import Node
from launch.actions import DeclareLaunchArgument, ExecuteProcess, OpaqueFunction
from launch.substitutions import LaunchConfiguration
from ament_index_python.packages import get_package_share_directory


def launch_setup(context, *args, **kwargs):
    # ==== 获取参数 ====
    tcp_ip = LaunchConfiguration('tcp_ip').perform(context)
    tcp_port = int(LaunchConfiguration('tcp_port').perform(context))
    use_rviz = LaunchConfiguration('use_rviz').perform(context).lower() == 'true'
    play_bag_flag = LaunchConfiguration('play_bag').perform(context).lower() == 'true'

    # ==== ROS2 节点 ====
    upper_node = Node(
        package='upper',
        executable='upper_node',
        name='upper',
        parameters=[{
            'tcp_ip': tcp_ip,
            'tcp_port': tcp_port
        }],
        output='screen'
    )

    actions = [upper_node]

    # ==== 选择是否播放 bag 文件 ====
    if play_bag_flag:
        upper_pkg_dir = get_package_share_directory('upper')
        bag_dir = os.path.join(upper_pkg_dir, 'bag')  # 相对包路径
        if os.path.exists(bag_dir):
            bag_files = [os.path.join(bag_dir, f) for f in os.listdir(bag_dir) if f.endswith('.db3')]
            if bag_files:
                play_bag = ExecuteProcess(
                    cmd=['ros2', 'bag', 'play', '--loop'] + bag_files,
                    output='screen'
                )
                actions.append(play_bag)
            else:
                print(f"[WARN] No bag files found in {bag_dir}")
        else:
            print(f"[WARN] Bag directory not found: {bag_dir}")

    # ==== 选择是否启动 RViz ====
    if use_rviz:
        lslidar_pkg_dir = get_package_share_directory('lslidar_driver')
        rviz_file = os.path.join(lslidar_pkg_dir, 'rviz', 'lslidar.rviz')
        if os.path.exists(rviz_file):
            rviz_proc = ExecuteProcess(
                cmd=['rviz2', '-d', rviz_file],
                output='screen'
            )
            actions.append(rviz_proc)
        else:
            print(f"[WARN] RViz file not found: {rviz_file}")

    return actions


def generate_launch_description():
    # ==== 参数声明 ====
    tcp_ip_arg = DeclareLaunchArgument(
        'tcp_ip',
        default_value='0.0.0.0',
        description='TCP listen IP (use 0.0.0.0 to listen on all interfaces)'
    )
    tcp_port_arg = DeclareLaunchArgument(
        'tcp_port',
        default_value='6666',
        description='TCP listen port (integer)'
    )
    use_rviz_arg = DeclareLaunchArgument(
        'use_rviz',
        default_value='false',
        description='Whether to start RViz2 (true/false)'
    )
    play_bag_arg = DeclareLaunchArgument(
        'play_bag',
        default_value='false',
        description='Whether to play bag file in loop (true/false)'
    )

    return LaunchDescription([
        tcp_ip_arg,
        tcp_port_arg,
        use_rviz_arg,
        play_bag_arg,
        OpaqueFunction(function=launch_setup)
    ])
```

`gedit ~/slam_ws/src/upper/src/upper.cpp`

```
#include <chrono>
#include <memory>
#include <string>
#include <vector>
#include <set>
#include <mutex>
#include <fcntl.h>
#include <unistd.h>
#include <iostream>
#include <iomanip>
#include <sstream>
#include <cstring>
#include <cerrno>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <filesystem>
#include <fstream>

#include <yaml-cpp/yaml.h>
#include <nlohmann/json.hpp>

#include "rclcpp/rclcpp.hpp"
#include "sensor_msgs/msg/laser_scan.hpp"
#include "nav_msgs/msg/occupancy_grid.hpp"
#include "tf2_msgs/msg/tf_message.hpp"
#include "ament_index_cpp/get_package_share_directory.hpp"

using json = nlohmann::json;
using namespace std::chrono_literals;
namespace fs = std::filesystem;

class TcpSender : public rclcpp::Node
{
public:
    TcpSender() : Node("tcp_sender"), listen_sock_(-1)
    {
        package_share_dir_ = ament_index_cpp::get_package_share_directory("upper");

        this->declare_parameter<std::string>("tcp_ip", "0.0.0.0");
        this->declare_parameter<int>("tcp_port", 6666);

        tcp_ip_ = this->get_parameter("tcp_ip").as_string();
        tcp_port_ = this->get_parameter("tcp_port").as_int();

        startTcpServer();

        tf_sub_ = this->create_subscription<tf2_msgs::msg::TFMessage>(
            "/tf", 10, std::bind(&TcpSender::tfCallback, this, std::placeholders::_1));
        scan_sub_ = this->create_subscription<sensor_msgs::msg::LaserScan>(
            "/scan", 10, std::bind(&TcpSender::scanCallback, this, std::placeholders::_1));
        map_sub_ = this->create_subscription<nav_msgs::msg::OccupancyGrid>(
            "/map", 1, std::bind(&TcpSender::mapCallback, this, std::placeholders::_1));

        tcp_accept_timer_ = this->create_wall_timer(200ms, std::bind(&TcpSender::acceptPendingClients, this));
        tcp_recv_timer_ = this->create_wall_timer(100ms, std::bind(&TcpSender::checkTcpRecv, this));
        rate_timer_ = this->create_wall_timer(10s, std::bind(&TcpSender::logRates, this));
    }

    ~TcpSender()
    {
        if (listen_sock_ != -1) close(listen_sock_);
        for (int c : clients_) close(c);
    }

private:
    // ======== TCP Server ========
    void startTcpServer()
    {
        listen_sock_ = socket(AF_INET, SOCK_STREAM, 0);
        if (listen_sock_ < 0)
        {
            RCLCPP_ERROR(this->get_logger(), "socket创建失败: %s", strerror(errno));
            return;
        }

        int opt = 1;
        setsockopt(listen_sock_, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

        sockaddr_in addr {};
        addr.sin_family = AF_INET;
        addr.sin_port   = htons(tcp_port_);
        addr.sin_addr.s_addr = inet_addr(tcp_ip_.c_str());

        if (bind(listen_sock_, (struct sockaddr *)&addr, sizeof(addr)) < 0)
        {
            RCLCPP_ERROR(this->get_logger(), "端口被占用，Bind failed: %s", strerror(errno));
            return;
        }

        listen(listen_sock_, 5);
        fcntl(listen_sock_, F_SETFL, O_NONBLOCK);
        RCLCPP_INFO(this->get_logger(), "TCP 正在监听 %s:%d", tcp_ip_.c_str(), tcp_port_);
    }

    void acceptPendingClients()
    {
        sockaddr_in caddr {};
        socklen_t clen = sizeof(caddr);
        int client_fd = accept(listen_sock_, (struct sockaddr *)&caddr, &clen);
        if (client_fd < 0) return;

        fcntl(client_fd, F_SETFL, O_NONBLOCK);
        clients_.insert(client_fd);
        RCLCPP_INFO(this->get_logger(), "新的TCP上位机连接成功, fd=%d", client_fd);
    }

    // ======== TCP 数据接收与解析 ========
    void checkTcpRecv()
    {
        uint8_t buf[256];
        for (auto it = clients_.begin(); it != clients_.end();)
        {
            ssize_t n = recv(*it, buf, sizeof(buf), 0);
            if (n <= 0)
            {
                ++it;
                continue;
            }

            bytes_recv_tcp_ += n;

            std::ostringstream oss;
            oss << "Recv (" << n << " bytes): ";
            for (ssize_t i = 0; i < n; ++i)
                oss << std::hex << std::uppercase << std::setw(2) << std::setfill('0')
                    << static_cast<int>(buf[i]) << " ";
            RCLCPP_INFO(this->get_logger(), "%s", oss.str().c_str());

            // === 通信测试命令: AA 00 01 0A ===
            for (ssize_t i = 0; i < n - 3; ++i)
            {
                if (buf[i] == 0xAA && buf[i + 1] == 0x00 &&
                    buf[i + 2] == 0x01 && buf[i + 3] == 0x0A)
                {
                    uint8_t reply[4] = {0xAA, 0x00, 0x01, 0x0A};
                    send(*it, reply, sizeof(reply), 0);
                    RCLCPP_INFO(this->get_logger(), "收到测试指令，回发 AA 00 01 0A");
                }
            }

            // === 保存地图命令: AA 00 02 0A ===
            for (ssize_t i = 0; i < n - 3; ++i)
            {
                if (buf[i] == 0xAA && buf[i + 1] == 0x00 &&
                    buf[i + 2] == 0x02 && buf[i + 3] == 0x0A)
                {
                    handleMapSaveCommand();
                    RCLCPP_INFO(this->get_logger(), "收到保存地图指令 AA 00 02 0A");
                }
            }

            // === 发送参数命令: AA 00 03 0A ===
            for (ssize_t i = 0; i < n - 3; ++i)
            {
                if (buf[i] == 0xAA && buf[i + 1] == 0x00 &&
                    buf[i + 2] == 0x03 && buf[i + 3] == 0x0A)
                {
                    handleSendParamsCommand();
                    RCLCPP_INFO(this->get_logger(), "收到读取参数指令 AA 00 03 0A");
                }
            }

            // === 参数修改命令: AA 10 param_id val_high val_low 0A ===
            for (ssize_t i = 0; i < n - 5; ++i)
            {
                if (buf[i] == 0xAA && buf[i + 1] == 0x10 && buf[i + 5] == 0x0A)
                {
                    uint8_t param_id = buf[i + 2];
                    uint16_t value = (buf[i + 3] << 8) | buf[i + 4];
                    handleParamCommand(param_id, value);
                    RCLCPP_INFO(this->get_logger(), "收到参数修改: id=%d value=%d", param_id, value);
                }
            }

            ++it;
        }
    }

    // ======== 发送参数到上位机 ========
    void handleSendParamsCommand()
    {
        std::string file_path = package_share_dir_ + "/config/params.yaml";
        YAML::Node config;
        try {
            config = YAML::LoadFile(file_path);
        } catch (const std::exception &e) {
            RCLCPP_ERROR(this->get_logger(), "无法打开 %s: %s", file_path.c_str(), e.what());
            return;
        }

        std::string lidar_name = config["lidar_name"] ? config["lidar_name"].as<std::string>() : "N10";
        float x = config["x"] ? config["x"].as<float>() : 0.0f;
        float y = config["y"] ? config["y"].as<float>() : 0.0f;
        float z = config["z"] ? config["z"].as<float>() : 0.0f;
        float roll = config["roll"] ? config["roll"].as<float>() : 0.0f;
        float pitch = config["pitch"] ? config["pitch"].as<float>() : 0.0f;
        float yaw = config["yaw"] ? config["yaw"].as<float>() : 0.0f;
        std::string mode = config["mode"] ? config["mode"].as<std::string>() : "mapping";

        sendParamToClients(0x00, (lidar_name == "N10") ? 0 : 1);
        sendParamToClients(0x01, static_cast<uint16_t>(x));
        sendParamToClients(0x02, static_cast<uint16_t>(y));
        sendParamToClients(0x03, static_cast<uint16_t>(z));
        sendParamToClients(0x04, static_cast<uint16_t>(roll));
        sendParamToClients(0x05, static_cast<uint16_t>(pitch));
        sendParamToClients(0x06, static_cast<uint16_t>(yaw));
        sendParamToClients(0x10, (mode == "mapping") ? 0 : 1);

        RCLCPP_INFO(this->get_logger(), "参数已从 YAML 文件读取并发送");
    }

    void sendParamToClients(uint8_t param_id, uint16_t value)
    {
        std::vector<uint8_t> packet = {0xAA, 0x10, param_id,
            static_cast<uint8_t>((value >> 8) & 0xFF),
            static_cast<uint8_t>(value & 0xFF),
            0x0A};
        sendPacket(packet);
    }

    // ======== 修改 params.yaml ========
    void handleParamCommand(uint8_t param_id, uint16_t value)
    {
        namespace fs = std::filesystem;
        const std::string file_path = fs::path(package_share_dir_) / "config" / "params.yaml";

        YAML::Node cfg;
        try {
            cfg = YAML::LoadFile(file_path);
        } catch (const std::exception& e) {
            RCLCPP_ERROR(get_logger(), "加载 YAML 失败: %s", e.what());
            return;
        }

        /* 更新节点 */
        switch (param_id) {
            case 0x00: cfg["lidar_name"] = (value == 0 ? "N10" : "N10_P"); break;
            case 0x01: cfg["x"]         = static_cast<int>(value); break;
            case 0x02: cfg["y"]         = static_cast<int>(value); break;
            case 0x03: cfg["z"]         = static_cast<int>(value); break;
            case 0x04: cfg["roll"]      = static_cast<int>(value); break;
            case 0x05: cfg["pitch"]     = static_cast<int>(value); break;
            case 0x06: cfg["yaw"]       = static_cast<int>(value); break;
            case 0x10: cfg["mode"]      = (value == 0 ? "mapping" : "localization"); break;
            default:
                RCLCPP_WARN(get_logger(), "未知 param_id: %u", param_id);
                return;
        }

        /* 写回文件 */
        try {
            std::ofstream fout(file_path);
            fout << "# 雷达型号选择: N10, N10_P\n"
                << "lidar_name: " << cfg["lidar_name"].as<std::string>() << "\n\n"
                << "# 定义 base_link -> laser_link 的固定 TF 变换，单位cm和度\n"
                << "x: "      << cfg["x"].as<int>()    << "\n"
                << "y: "      << cfg["y"].as<int>()    << "\n"
                << "z: "      << cfg["z"].as<int>()    << "\n"
                << "roll: "   << cfg["roll"].as<int>() << "\n"
                << "pitch: "  << cfg["pitch"].as<int>()<< "\n"
                << "yaw: "    << cfg["yaw"].as<int>()  << "\n\n"
                << "# SLAM_TOOLBOX建图or定位模式，mapping/localization\n"
                << "mode: "   << cfg["mode"].as<std::string>() << "\n";
            RCLCPP_INFO(get_logger(), "已更新并保存 %s", file_path.c_str());
        } catch (const std::exception& e) {
            RCLCPP_ERROR(get_logger(), "保存 YAML 失败: %s", e.what());
        }
    }

    // ======== 保存地图为YAML和PGM格式 ========
    void handleMapSaveCommand()
    {
        if (!last_map_)
        {
            RCLCPP_WARN(this->get_logger(), "没有/map话题数据");
            return;
        }

        std::string dir_path = package_share_dir_ + "/map/";
        if (!fs::exists(dir_path))
            fs::create_directories(dir_path);

        std::string yaml_path = dir_path + "my_map.yaml";
        std::string pgm_path  = dir_path + "my_map.pgm";

        if (!saveMapAsPGM(pgm_path) || !saveMapAsYAML(yaml_path, pgm_path))
            return;

        RCLCPP_INFO(this->get_logger(), "Map 成功保存在 %s 和 %s", yaml_path.c_str(), pgm_path.c_str());
    }

    bool saveMapAsPGM(const std::string& file_path)
    {
        std::ofstream ofs(file_path, std::ios::binary);
        if (!ofs.is_open())
        {
            RCLCPP_ERROR(this->get_logger(), "无法打开 PGM 文件: %s", file_path.c_str());
            return false;
        }

        const auto& map = last_map_;
        int width = map->info.width;
        int height = map->info.height;

        ofs << "P5\n" << width << " " << height << "\n255\n";
        for (int y = 0; y < height; ++y)
        {
            for (int x = 0; x < width; ++x)
            {
                int index = y * width + x;
                int8_t value = map->data[index];
                uint8_t pgm_value;
                if (value == -1) pgm_value = 205;
                else pgm_value = static_cast<uint8_t>((100 - value) * 254 / 100);
                ofs << pgm_value;
            }
        }
        return true;
    }

    bool saveMapAsYAML(const std::string& yaml_path, const std::string& pgm_path)
    {
        std::ofstream ofs(yaml_path);
        if (!ofs.is_open())
        {
            RCLCPP_ERROR(this->get_logger(), "无法打开 YAML 文件: %s", yaml_path.c_str());
            return false;
        }

        const auto& map = last_map_;
        ofs << "image: my_map.pgm\n"
            << "resolution: " << map->info.resolution << "\n"
            << "origin: [" << map->info.origin.position.x << ", "
                          << map->info.origin.position.y << ", "
                          << map->info.origin.position.z << "]\n"
            << "negate: 0\n"
            << "occupied_thresh: 0.65\n"
            << "free_thresh: 0.196\n";
        return true;
    }

    // ======== ROS2 回调 ========
    void tfCallback(const tf2_msgs::msg::TFMessage::SharedPtr msg)
    {
        if (msg->transforms.empty()) return;
        const auto &t = msg->transforms[0];
        json j;
        j["topic"] = "tf";
        j["frame_id"] = t.header.frame_id;
        j["child_frame_id"] = t.child_frame_id;
        j["x"] = t.transform.translation.x;
        j["y"] = t.transform.translation.y;
        j["z"] = t.transform.translation.z;
        j["qx"] = t.transform.rotation.x;
        j["qy"] = t.transform.rotation.y;
        j["qz"] = t.transform.rotation.z;
        j["qw"] = t.transform.rotation.w;
        sendJsonPacket(0x01, j.dump());
    }

    void scanCallback(const sensor_msgs::msg::LaserScan::SharedPtr msg)
    {
        if (msg->ranges.empty()) return;
        json j;
        j["topic"] = "scan";
        j["angle_min"] = msg->angle_min;
        j["angle_max"] = msg->angle_max;
        j["angle_increment"] = msg->angle_increment;
        j["range_count"] = msg->ranges.size();
        j["ranges"] = msg->ranges;
        sendJsonPacket(0x02, j.dump());
    }

    void mapCallback(const nav_msgs::msg::OccupancyGrid::SharedPtr msg)
    {
        if (msg->data.empty()) return;

        last_map_ = msg; // 保存最新地图

        json j;
        j["topic"] = "map";
        j["width"] = msg->info.width;
        j["height"] = msg->info.height;
        j["resolution"] = msg->info.resolution;
        j["origin_x"] = msg->info.origin.position.x;
        j["origin_y"] = msg->info.origin.position.y;

        // RLE 压缩
        std::vector<std::pair<int, int>> rle;
        const auto &data = msg->data;
        if (!data.empty()) {
            int current = data[0];
            int count = 1;
            for (size_t i = 1; i < data.size(); ++i) {
                if (data[i] == current && count < 255)
                    count++;
                else {
                    rle.emplace_back(current, count);
                    current = data[i];
                    count = 1;
                }
            }
            rle.emplace_back(current, count);
        }

        json rle_json = json::array();
        for (auto &p : rle)
            rle_json.push_back({p.first, p.second});
        j["rle"] = rle_json;

        sendJsonPacket(0x03, j.dump());
    }

    // ======== JSON 发送 ========
    void sendJsonPacket(uint8_t topic_id, const std::string &json_str)
    {
        std::vector<uint8_t> packet;
        packet.push_back(0xAA);
        packet.push_back(topic_id);
        packet.insert(packet.end(), json_str.begin(), json_str.end());
        packet.push_back(0x0A);
        sendPacket(packet);
    }

    // ======== 实际发送 ========
    void sendPacket(const std::vector<uint8_t> &packet)
    {
        for (auto it = clients_.begin(); it != clients_.end();)
        {
            ssize_t n = send(*it, packet.data(), packet.size(), 0);
            if (n <= 0)
            {
                close(*it);
                it = clients_.erase(it);
            }
            else
            {
                bytes_sent_tcp_ += n;
                ++it;
            }
        }
    }

    void logRates()
    {
        RCLCPP_INFO(this->get_logger(), "TCP发送累计字节: %lu, 接收累计字节: %lu",
                    bytes_sent_tcp_, bytes_recv_tcp_);
    }

    // ========== 成员变量 ==========
    std::string tcp_ip_;
    int tcp_port_;
    int listen_sock_;
    std::set<int> clients_;
    std::mutex mtx_;

    std::string package_share_dir_;

    size_t bytes_sent_tcp_ = 0;
    size_t bytes_recv_tcp_ = 0;

    rclcpp::Subscription<tf2_msgs::msg::TFMessage>::SharedPtr tf_sub_;
    rclcpp::Subscription<sensor_msgs::msg::LaserScan>::SharedPtr scan_sub_;
    rclcpp::Subscription<nav_msgs::msg::OccupancyGrid>::SharedPtr map_sub_;
    nav_msgs::msg::OccupancyGrid::SharedPtr last_map_;

    rclcpp::TimerBase::SharedPtr tcp_accept_timer_;
    rclcpp::TimerBase::SharedPtr tcp_recv_timer_;
    rclcpp::TimerBase::SharedPtr rate_timer_;
};

int main(int argc, char *argv[])
{
    rclcpp::init(argc, argv);
    auto node = std::make_shared<TcpSender>();
    rclcpp::spin(node);
    rclcpp::shutdown();
    return 0;
}
```

`gedit ~/slam_ws/src/upper/CMakeLists.txt`

```bash
cmake_minimum_required(VERSION 3.5)
project(upper)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# -----------------------------------------------------------------------------
# 查找依赖
# -----------------------------------------------------------------------------
find_package(ament_cmake REQUIRED)
find_package(rclcpp REQUIRED)
find_package(nav_msgs REQUIRED)
find_package(sensor_msgs REQUIRED)
find_package(tf2_msgs REQUIRED)
find_package(std_msgs REQUIRED)
find_package(nlohmann_json REQUIRED)
find_package(yaml-cpp REQUIRED)

# -----------------------------------------------------------------------------
# 编译节点
# -----------------------------------------------------------------------------
add_executable(${PROJECT_NAME}_node src/upper.cpp)

ament_target_dependencies(${PROJECT_NAME}_node
  rclcpp
  nav_msgs
  sensor_msgs
  tf2_msgs
  std_msgs
)

# 链接 JSON 和 YAML 库
target_link_libraries(${PROJECT_NAME}_node
  yaml-cpp
  nlohmann_json::nlohmann_json
)

# -----------------------------------------------------------------------------
# 安装
# -----------------------------------------------------------------------------
install(TARGETS ${PROJECT_NAME}_node
  DESTINATION lib/${PROJECT_NAME}
)

install(DIRECTORY launch
  DESTINATION share/${PROJECT_NAME}
)

install(DIRECTORY config
  DESTINATION share/${PROJECT_NAME}
)

ament_package()
```

`gedit ~/slam_ws/src/upper/package.xml`

```
<?xml version="1.0"?>
<package format="3">
  <name>upper</name>
  <version>0.0.1</version>
  <description>TCP sender node for ROS 2</description>

  <maintainer email="you@example.com">Your Name</maintainer>
  <license>Apache-2.0</license>

  <buildtool_depend>ament_cmake</buildtool_depend>

  <depend>rclcpp</depend>
  <depend>nav_msgs</depend>
  <depend>sensor_msgs</depend>
  <depend>tf2_msgs</depend>
  <depend>std_msgs</depend>
  
  <!-- 使用 ROS2 提供的 vendor 包而不是系统包 -->
  <depend>nlohmann_json_vendor</depend>
  <depend>tinyxml2_vendor</depend>

  <export>
    <build_type>ament_cmake</build_type>
  </export>
</package
```


```bash
cd ~/slam_ws
colcon build --packages-select upper
```

```bash
ros2 launch upper upper_launch.py

source ~/slam_ws/install/setup.bash
ros2 launch upper upper_launch.py
ros2 launch upper upper_launch.py tcp_ip:=0.0.0.0 tcp_port:=6666 use_rviz:=false play_bag:=true
```

#### 录制话题

```bash
# 录制所有话题
ros2 bag record -o ~/slam_ws/src/upper/bag -a
ls ~/slam_ws/src/upper/bag

# 播放话题
ros2 bag play ~/slam_ws/src/upper/bag/*.db3

# 删除后才能重新录制
sudo rm  -rf ~/slam_ws/src/upper/bag
```

