# 基于模块Humble，镭神 N10 SLAM添加pixhawk飞控的imu数据
**px4版本为1.13.3，其余版本没有验证**

---

## 机载电脑下载MAVROS，实现通信

修改QGC中参数
```
# mavlink通道0设置为TELLEM1
- MAV_1_CONFIG     TELLEM2

# 设置为onborad模式才会发送线加速度
- MAV_1_MODE       Onboard

# 设置TELLEM2通信波特率
- SER_TEL1_BAUD    921600 8N1

# 设置TELLEM1的速度b/s，0则飞控自适应
- MAV_1_RATE       0
```

```
# QGC的MavLink工作台输入
mavlink status streams
# 可见imu输出频率2.5
instance #1:
HIGHRES_IMU                    50.00 (2.500)
# 设置输出频率50hz
mavlink stream -r 50 -s HIGHRES_IMU
mavlink status streams
# 可见
instance #1:
HIGHRES_IMU                    50.00 (2.500)
```

**注意飞控不能3v3供电**
```
模块通过串口/dev/ttyS3连接TELLEM1
TELLEM1  5V  TX  RX CTS RTS GND  
mode     3V3 3V3 GND TX RX
```

安装MAVROS

参考：https://blog.csdn.net/weixin_42037083/article/details/137102858

```bash
sudo apt-get install ros-humble-mavros ros-humble-mavros-extras
```

安装geographiclib

```bash
cd ~
git clone https://github.com/weisama/GeographicLib.git
sudo cp -r ~/GeographicLib /usr/share
```

设置mode串口

查看串口消息

```bash
sudo dmesg | tail
ls /dev/ttyS*
sudo usermod -aG dialout $USER
sudo chmod 777 /dev/ttyS3
```

修改mavros串口设备和波特率

```bash
sudo nano /opt/ros/humble/share/mavros/launch/px4.launch
```

```xml
<arg name="fcu_url" default="/dev/ttyS3:921600" />
```

```bash
ros2 launch mavros px4.launch
ros2 launch mavros px4.launch fcu_url:=/dev/ttyS3:921600
ros2 topic list
```

### 检查MAVROS状态

```bash
# 飞控状态
ros2 topic echo /mavros/state

# EKF2的imu数据,坐标系为base_link则不修改tf变换
ros2 topic echo /mavros/imu/data

# 频率50hz满足要求
ros2 topic hz /mavros/imu/data

# 原始imu数据，不建议使用
ros2 topic echo /mavros/imu/data_raw
```

## pose_send功能包，slam输出tf作为飞控位置输入

```bash
cd ~/slam_ws/src
ros2 pkg create --build-type ament_cmake pose_send --dependencies rclcpp tf2_ros geometry_msgs
```

`mousepad ~/slam_ws/src/pose_send/src/pose_send_node.cpp`

```
#include "rclcpp/rclcpp.hpp"
#include "geometry_msgs/msg/pose_stamped.hpp"
#include "tf2_ros/transform_listener.h"
#include "tf2_ros/buffer.h"
#include "tf2_geometry_msgs/tf2_geometry_msgs.hpp"

class PoseSendNode : public rclcpp::Node
{
public:
    PoseSendNode() : Node("pose_send_node")
    {
        pose_pub_ = this->create_publisher<geometry_msgs::msg::PoseStamped>(
            "/mavros/vision_pose/pose", 10);

        tf_buffer_ = std::make_unique<tf2_ros::Buffer>(this->get_clock());
        tf_listener_ = std::make_shared<tf2_ros::TransformListener>(*tf_buffer_);

        timer_ = this->create_wall_timer(
            std::chrono::milliseconds(50),
            std::bind(&PoseSendNode::publish_pose, this));

        RCLCPP_INFO(this->get_logger(), "pose_send_node started. Waiting for map→odom and odom→base_link...");
    }

private:
    void publish_pose()
    {
        try
        {
            // 1. 获取 map→odom
            geometry_msgs::msg::TransformStamped map_to_odom =
                tf_buffer_->lookupTransform("map", "odom", tf2::TimePointZero);

            // 2. 获取 odom→base_link
            geometry_msgs::msg::TransformStamped odom_to_base =
                tf_buffer_->lookupTransform("odom", "base_link", tf2::TimePointZero);

            // 3. 组合为 map→base_link
            geometry_msgs::msg::TransformStamped map_to_base;
            tf2::Transform tf_map_to_odom, tf_odom_to_base, tf_map_to_base;
            tf2::fromMsg(map_to_odom.transform, tf_map_to_odom);
            tf2::fromMsg(odom_to_base.transform, tf_odom_to_base);
            tf_map_to_base = tf_map_to_odom * tf_odom_to_base;

            map_to_base.header.stamp = this->get_clock()->now();
            map_to_base.header.frame_id = "map";
            map_to_base.child_frame_id = "base_link";
            map_to_base.transform = tf2::toMsg(tf_map_to_base);

            // 4. 转为 PoseStamped 并发布
            geometry_msgs::msg::PoseStamped pose_msg;
            pose_msg.header = map_to_base.header;
            pose_msg.pose.position.x = map_to_base.transform.translation.x;
            pose_msg.pose.position.y = map_to_base.transform.translation.y;
            pose_msg.pose.position.z = map_to_base.transform.translation.z;
            pose_msg.pose.orientation = map_to_base.transform.rotation;

            pose_pub_->publish(pose_msg);
        }
        catch (tf2::TransformException &ex)
        {
            RCLCPP_WARN_THROTTLE(this->get_logger(), *this->get_clock(), 5000,
                                 "TF not available yet: %s", ex.what());
        }
    }

    rclcpp::Publisher<geometry_msgs::msg::PoseStamped>::SharedPtr pose_pub_;
    std::shared_ptr<tf2_ros::TransformListener> tf_listener_;
    std::unique_ptr<tf2_ros::Buffer> tf_buffer_;
    rclcpp::TimerBase::SharedPtr timer_;
};

int main(int argc, char **argv)
{
    rclcpp::init(argc, argv);
    rclcpp::spin(std::make_shared<PoseSendNode>());
    rclcpp::shutdown();
    return 0;
}
```


`mousepad ~/slam_ws/src/pose_send/CMakeLists.txt`

```
cmake_minimum_required(VERSION 3.8)
project(pose_send)

find_package(ament_cmake REQUIRED)
find_package(rclcpp REQUIRED)
find_package(geometry_msgs REQUIRED)
find_package(tf2_msgs REQUIRED)

add_executable(pose_send_node src/pose_send_node.cpp)
ament_target_dependencies(pose_send_node
  rclcpp
  geometry_msgs
  tf2_msgs
)

install(TARGETS
  pose_send_node
  DESTINATION lib/${PROJECT_NAME}
)

ament_package()
```

`mousepad ~/slam_ws/src/pose_send/package.xml`

```
  <buildtool_depend>ament_cmake</buildtool_depend>
  <depend>rclcpp</depend>
  <depend>geometry_msgs</depend>
  <depend>tf2_msgs</depend>
```

```
cd ~/slam_ws
colcon build --packages-select pose_send

ros2 run pose_send pose_send_node
```

